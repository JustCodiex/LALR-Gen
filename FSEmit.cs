namespace ParserGen;

internal static class FSEmit {

    internal class FSharpSemanticAction {
        public string Action { get; }
        public string[] Args { get; }
        public int MaxArg { get; }
        internal FSharpSemanticAction(Production p) {
            string action = p.SemanticInput;
            this.MaxArg = p.Rhs.Length;
            int argc = 0;
            List<string> args = new List<string>();
            for (int i = 0; i < this.MaxArg; i++) {
                string pattern = $"${i + 1}";
                int count = CountSubstring(action, pattern);
                if (count > 0) {
                    string c = ((char)('a' + (char)argc++)).ToString();
                    args.Add(c);
                    action = action.Replace(pattern, c);
                }
            }
            this.Args = args.ToArray();
            this.Action = action;
        }
        public static int CountSubstring(string text, string value) {
            int count = 0, minIndex = text.IndexOf(value, 0);
            while (minIndex != -1) {
                minIndex = text.IndexOf(value, minIndex + value.Length);
                count++;
            }
            return count;
        }
        public override string ToString() {
            return this.Action;
        }
    }

    internal static void Emit(Table<LR1Action> table, Grammar G, string parseOutput) {

        // Open .fs
        using var src_fs = File.Open(parseOutput, FileMode.Create);
        using var src_sw = new StreamWriter(src_fs);

        // Open .fsi
        using var sig_fs = File.Open(parseOutput.Replace(".fs", ".fsi"), FileMode.Create);
        using var sig_sw = new StreamWriter(sig_fs);

        // Write header
        WriteHead(src_sw, sig_sw);

        // Write using
        foreach (string ln in G.Using) {
            WriteDual(src_sw, sig_sw, ln);
        }

        // Write types
        WriteTypes(src_sw, sig_sw, G);

        // Write parse table to .fs file
        WriteTable(src_sw, sig_sw, table, G.EmptySymbol.Index, Grammar.EndOfInput.Index);

        // Write semantics
        WriteDual(src_sw, sig_sw, "// Semantic dispatcher");
        sig_sw.WriteLine("val sem_dispatch : StackElement list -> int -> SemanticAction");
        src_sw.WriteLine("let sem_dispatch stack = function");
        for (int i = 0; i < G.Productions.Count; i++) {
            src_sw.WriteLine($"| {i} -> {{ nodeType = {new FSharpSemanticAction(G.Productions[i])}; stack = stack }}");
        }
        src_sw.WriteLine($"| _ -> failwith \"Invalid semantic action ID\"");
        src_sw.WriteLine();

        // Write symbols
        src_sw.WriteLine("// Symbols");
        src_sw.WriteLine($"let symbol_pattern = function");
        foreach (var sym in G.Symbols.OrderBy(x => x.Value.Index)) {
            src_sw.WriteLine($"| \"{sym.Key}\" -> ({sym.Value.Index}, {sym.Value.IsTerminal.ToString().ToLowerInvariant()}, {sym.Value.IsNullable.ToString().ToLowerInvariant()})");
        }
        src_sw.WriteLine($"| _ -> (-1, false, false)");
        src_sw.WriteLine();

        // Write index fetcher
        sig_sw.WriteLine();
        WriteDual(src_sw, sig_sw, "// Symb ID fetcher");
        WriteFunc(src_sw, sig_sw, "symbolStr2ID", "string -> int", "str", "let (i, _, _) = symbol_pattern str in i");
        WriteDual(src_sw, sig_sw, "");

        // Write productions
        src_sw.WriteLine("// Productions");
        src_sw.WriteLine("let prod_list = [");
        int j = 0;
        foreach (var p in G.Productions.OrderBy(x => x.Index)) {
            src_sw.Write($"    ({p.Lhs.Index}, [{string.Join(';', p.Rhs.Select(x => x.Index))}])");
            if (j + 1 < G.Productions.Count) {
                src_sw.WriteLine(";");
            }
            j++;
        }
        src_sw.WriteLine("]");
        src_sw.WriteLine("");

        // Write production tuple fetcher
        WriteDual(src_sw, sig_sw, "// Production fetcher");
        WriteFunc(src_sw, sig_sw, "prod_lookup", "int -> int * int list", "i", "prod_list[i]");
        WriteDual(src_sw, sig_sw, "");

    }

    internal static void WriteDual(StreamWriter src, StreamWriter sig, string content) {
        src.WriteLine(content);
        sig.WriteLine(content);
    }

    internal static void WriteHead(StreamWriter src, StreamWriter sig) {
        WriteDual(src, sig, "// This file was auto-generated by an LALR(1) - Parse Table generator.");
        WriteDual(src, sig, "module ParserSemantics");
        WriteDual(src, sig, string.Empty);
    }

    internal static void WriteSemant(StreamWriter src,  int index, FSharpSemanticAction semanticAction) {
        src.WriteLine($"let sem{index:000} stack = {{ nodeType = {semanticAction}; stack = stack }}");
    }

    internal static void WriteFunc(StreamWriter src, StreamWriter sig, string name, string types, string args, string body, bool export = true) {
        if (export) {
            sig.WriteLine($"val {name} : {types}");
        }
        src.WriteLine($"let {name} {args} = {body}");
    }

    internal static void WriteTypes(StreamWriter src, StreamWriter sig, Grammar G) {

        // Write action type
        WriteDual(src, sig, "// Parser actions");
        WriteDual(src, sig, "type Action = ");
        WriteDual(src, sig, "| Accept of int");
        WriteDual(src, sig, "| Shift of uint64");
        WriteDual(src, sig, "| Reduce of uint64");
        WriteDual(src, sig, "| Goto of uint64");
        WriteDual(src, sig, "| Error");
        WriteDual(src, sig, "");

        // Write stack element
        WriteDual(src, sig, "// Parser Stack element");
        WriteDual(src, sig, "type StackElement = ");
        WriteDual(src, sig, "| Token of LexToken");
        WriteDual(src, sig, "| Action of SemanticAction");
        WriteDual(src, sig, "and SemanticAction = { nodeType: SemanticActionType; stack: StackElement list }");
        WriteDual(src, sig, "");

        // Write a default error
        src.WriteLine("// Basic helpers error");
        src.WriteLine("let a = Accept 1");
        src.WriteLine("let r p = Reduce (uint64 p)");
        src.WriteLine("let s t = Shift (uint64 t)");
        src.WriteLine("let g s = Goto (uint64 s)");
        src.WriteLine("let e = Error");
        src.WriteLine();

        // Write class
        foreach (string ln in G.InClass) {
            src.WriteLine(ln);
        }

    }

    internal static void WriteTable(StreamWriter src, StreamWriter sig, Table<LR1Action> table, int eps, int eof) {

        // Loop over
        src.WriteLine("// Lookup table");
        src.WriteLine("let _table =");
        src.WriteLine("    array2D [");
        for (int row = 0; row < table.Rows; row++) {
            src.Write("        [");
            for (int col = 0; col < table.Columns; col++) {

                // Get cell
                var cell = table[row, col];

                // Action type
                var arg = cell.Action switch {
                    ActionType.Accept => $"a",
                    ActionType.Reduce => $"r {cell.ActionArgument}",
                    ActionType.Shift => $"s {cell.ActionArgument}",
                    ActionType.Error => "e",
                    ActionType.Goto => $"g {cell.ActionArgument}",
                    _ => ""
                };

                // Check
                if (arg.Length > 0) {
                    src.Write(arg);
                    if (col + 1 < table.Columns) {
                        src.Write("; ");
                    }
                }

            }
            src.Write("]");
            if (row + 1 < table.Rows) {
                src.WriteLine(";");
            } else {
                src.WriteLine();
            }
        }
        src.WriteLine("    ]");
        src.WriteLine("");

        // Write lookup
        WriteDual(src, sig, "// Lookup function for lookup up the next action in table");
        WriteFunc(src, sig, "table_lookup", "uint64 -> int -> Action", "(state: uint64) (sym: int)", "_table[int state, sym]");
        WriteDual(src, sig, "");

        // Write eps ID
        WriteDual(src, sig, "// index of eps ");
        WriteFunc(src, sig, "eps_id", "int", "", eps.ToString());
        WriteDual(src, sig, "");

        // Write eof ID
        WriteDual(src, sig, "// index of EOF ");
        WriteFunc(src, sig, "eof_id", "int", "", eof.ToString());
        WriteDual(src, sig, "");

    }

}
